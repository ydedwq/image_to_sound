<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Аудио инструменты - Спектрограмма и преобразование изображения в звук</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        canvas {
            max-width: 100%;
            border: 1px solid #ddd;
            margin: 10px 0;
            display: block;
        }
        .spectrogram-canvas {
            background-color: #000;
        }
        button, input[type="file"] {
            margin: 10px 5px 10px 0;
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .status {
            margin: 10px 0;
            font-style: italic;
            color: #666;
        }
        .audio-controls {
            margin-top: 15px;
        }
        .progress-container {
            width: 100%;
            background-color: #f1f1f1;
            border-radius: 4px;
            margin: 15px 0;
        }
        .progress-bar {
            height: 20px;
            background-color: #4CAF50;
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s;
            text-align: center;
            color: white;
            font-size: 12px;
            line-height: 20px;
        }
        .spectrogram-container {
            position: relative;
            margin-top: 20px;
            overflow: hidden;
        }
        .frequency-legend {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
            color: white;
            font-size: 12px;
            pointer-events: none;
        }
        .time-legend {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: black;
            font-size: 12px;
            pointer-events: none;
        }
        .zoom-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .zoom-btn {
            padding: 5px 10px;
            background-color: #2196F3;
        }
        .zoom-value {
            margin: 0 10px;
            line-height: 30px;
        }
        .settings-panel {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .slider-container {
            margin: 15px 0;
        }
        label {
            display: inline-block;
            width: 150px;
        }
        .settings {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }
        .setting-group {
            flex: 1;
            min-width: 200px;
        }
        .image-resize-controls {
            margin: 15px 0;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }
        .dimension-display {
            font-family: monospace;
            margin-left: 10px;
        }
        .tab-buttons {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .tab-btn {
            padding: 10px 20px;
            background-color: #f1f1f1;
            border: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            cursor: pointer;
        }
        .tab-btn.active {
            background-color: #4CAF50;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="tab-buttons">
        <button class="tab-btn active" data-tab="image-to-sound">Изображение в звук</button>
        <button class="tab-btn" data-tab="description">Описание</button>
        <button class="tab-btn" data-tab="audio-analyzer">Анализатор аудио</button>
    </div>

    <div id="image-to-sound" class="tab-content active">
        <div class="container">
            <h1>Преобразователь изображения в звук</h1>
            
            <div>
                <h3>1. Загрузите изображение</h3>
                <input type="file" id="imageInput" accept="image/*">
                <canvas id="imageCanvas"></canvas>
                <div class="status" id="imageStatus"></div>
                
                <div class="image-resize-controls">
                    <h4>Настройки размера изображения</h4>
                    <div class="slider-container">
                        <label for="widthSlider">Ширина:</label>
                        <input type="range" id="widthSlider" min="100" max="2000" value="800">
                        <span class="dimension-display" id="widthValue">800</span> px
                    </div>
                    <div class="slider-container">
                        <label for="heightSlider">Высота:</label>
                        <input type="range" id="heightSlider" min="100" max="2000" value="400">
                        <span class="dimension-display" id="heightValue">400</span> px
                    </div>
                    <div class="slider-container">
                        <label for="keepAspectCheckbox">Сохранять пропорции:</label>
                        <input type="checkbox" id="keepAspectCheckbox" checked>
                    </div>
                    <button id="resizeImageBtn">Применить размер</button>
                </div>
                
                <div class="settings">
                    <div class="setting-group">
                        <div class="slider-container">
                            <label for="durationSlider">Длительность (сек):</label>
                            <input type="range" id="durationSlider" min="1" max="20" value="5" step="0.5">
                            <span id="durationValue">5</span>
                        </div>
                        
                        <div class="slider-container">
                            <label for="pitchSlider">Тональность:</label>
                            <input type="range" id="pitchSlider" min="0.1" max="3" value="1" step="0.1">
                            <span id="pitchValue">1</span>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <div class="slider-container">
                            <label for="fftSizeSlider1">Детализация FFT:</label>
                            <input type="range" id="fftSizeSlider1" min="9" max="14" value="12" step="1">
                            <span id="fftSizeValue1">4096</span>
                        </div>
                        
                        <div class="slider-container">
                            <label for="brightnessSlider1">Яркость звука:</label>
                            <input type="range" id="brightnessSlider1" min="0.5" max="2" value="1" step="0.1">
                            <span id="brightnessValue1">1</span>
                        </div>
                    </div>

                    <div class="setting-group">
                        <div class="slider-container">
                            <label for="smoothnessSlider">Плавность звука:</label>
                            <input type="range" id="smoothnessSlider" min="0.1" max="0.9" value="0.3" step="0.1">
                            <span id="smoothnessValue">0.3</span>
                        </div>
                        
                        <div class="slider-container">
                            <label for="stereoWidthSlider">Ширина стерео:</label>
                            <input type="range" id="stereoWidthSlider" min="0" max="1" value="0.5" step="0.1">
                            <span id="stereoWidthValue">0.5</span>
                        </div>
                    </div>
                </div>
                
                <div class="settings-panel">
                    <h4>Настройки экспорта аудио</h4>
                    <div class="slider-container">
                        <label for="sampleRateSelect">Частота дискретизации:</label>
                        <select id="sampleRateSelect">
                            <option value="44100">44.1 kHz (CD качество)</option>
                            <option value="48000">48 kHz (стандартная)</option>
                            <option value="96000">96 kHz (высокое качество)</option>
                        </select>
                    </div>
                    <div class="slider-container">
                        <label for="bitDepthSelect">Битовая глубина:</label>
                        <select id="bitDepthSelect">
                            <option value="16">16 бит (стандартная)</option>
                            <option value="24">24 бит (высокое качество)</option>
                            <option value="32">32 бит (максимальное качество)</option>
                        </select>
                    </div>
                </div>
                
                <button id="generateAudioBtn" disabled>Создать аудио из изображения</button>
                <div class="progress-container" id="progressContainer1">
                    <div class="progress-bar" id="progressBar1">0%</div>
                </div>
                <div class="audio-controls" id="audioControls" style="display: none;">
                    <audio id="audioPlayer1" controls></audio>
                    <button id="saveAudioBtn">Сохранить аудиофайл</button>
                    <select id="exportFormat">
                        <option value="wav">WAV (несжатый)</option>
                        <option value="mp3">MP3 (сжатый)</option>
                        <option value="ogg">OGG (сжатый)</option>
                    </select>
                </div>
                <div class="status" id="audioStatus1"></div>
            </div>
        </div>
    </div>

    <div id="description" class="tab-content">
        <div class="container">
            <h1>Описание работы с инструментами</h1>
            
            <div class="settings-panel">
                <h3>Преобразователь изображения в звук</h3>
                <p>Этот инструмент преобразует визуальную информацию изображения в аудиосигнал:</p>
                <ol>
                    <li><strong>Загрузите изображение</strong> - выберите файл изображения (JPG, PNG и др.)</li>
                    <li><strong>Настройте размер</strong> - укажите желаемые ширину и высоту для обработки</li>
                    <li><strong>Настройте параметры звука</strong>:
                        <ul>
                            <li>Длительность - продолжительность генерируемого аудио</li>
                            <li>Тональность - высота звучания (чем больше значение, тем выше тон)</li>
                            <li>Детализация FFT - влияет на частотное разрешение звука</li>
                            <li>Яркость звука - общая громкость аудио</li>
                            <li>Плавность звука - сглаживание переходов между частотами</li>
                            <li>Ширина стерео - пространственное распределение звука</li>
                        </ul>
                    </li>
                    <li><strong>Настройте экспорт</strong> - выберите качество аудио (частота дискретизации и битовая глубина)</li>
                    <li><strong>Создайте аудио</strong> - нажмите кнопку "Создать аудио из изображения"</li>
                    <li><strong>Сохраните результат</strong> - после генерации вы можете скачать аудиофайл</li>
                </ol>
            </div>
            
            <div class="settings-panel">
                <h3>Анализатор аудио</h3>
                <p>Этот инструмент создает спектрограмму загруженного аудиофайла:</p>
                <ol>
                    <li><strong>Загрузите аудиофайл</strong> - выберите файл (MP3, WAV и др.)</li>
                    <li><strong>Настройте параметры анализа</strong>:
                        <ul>
                            <li>Детализация FFT - влияет на точность частотного анализа</li>
                            <li>Контрастность - регулирует контраст спектрограммы</li>
                            <li>Яркость - регулирует общую яркость отображения</li>
                        </ul>
                    </li>
                    <li><strong>Анализируйте аудио</strong> - нажмите кнопку "Анализировать аудио"</li>
                    <li><strong>Работайте со спектрограммой</strong>:
                        <ul>
                            <li>Используйте кнопки "+/- Ширина" для масштабирования по горизонтали</li>
                            <li>Используйте кнопки "+/- Высота" для масштабирования по вертикали</li>
                            <li>Перетаскивайте спектрограмму мышью для просмотра разных участков</li>
                            <li>Нажмите "Сбросить" для возврата к исходному виду</li>
                        </ul>
                    </li>
                    <li><strong>Сохраните спектрограмму</strong> - нажмите кнопку "Сохранить спектрограмму"</li>
                </ol>
            </div>
            
            <div class="settings-panel">
                <h3>Техническая информация</h3>
                <p>Инструменты используют Web Audio API для обработки звука и Canvas API для визуализации.</p>
                <p>Для экспорта аудио в форматах MP3 и OGG используются библиотеки LameJS и Opus-Recorder.</p>
                <p>Частотный анализ выполняется с помощью быстрого преобразования Фурье (FFT).</p>
            </div>
        </div>
    </div>

    <div id="audio-analyzer" class="tab-content">
        <div class="container">
            <h1>Анализатор аудио</h1>
            
            <div>
                <h3>Загрузите аудиофайл</h3>
                <input type="file" id="audioInput" accept="audio/*">
                <div class="audio-controls">
                    <audio id="audioPlayer2" controls></audio>
                </div>
                <div class="status" id="audioStatus2"></div>
                
                <div class="settings-panel">
                    <h4>Настройки анализа</h4>
                    <div class="slider-container">
                        <label for="fftSizeSlider2">Детализация FFT:</label>
                        <input type="range" id="fftSizeSlider2" min="8" max="13" value="11">
                        <span id="fftSizeValue2">2048</span> точек
                    </div>
                    <div class="slider-container">
                        <label for="contrastSlider">Контрастность:</label>
                        <input type="range" id="contrastSlider" min="0.5" max="2" value="1" step="0.1">
                        <span id="contrastValue">1</span>
                    </div>
                    <div class="slider-container">
                        <label for="brightnessSlider2">Яркость:</label>
                        <input type="range" id="brightnessSlider2" min="0.5" max="2" value="1" step="0.1">
                        <span id="brightnessValue2">1</span>
                    </div>
                </div>
                
                <div class="progress-container" id="progressContainer2">
                    <div class="progress-bar" id="progressBar2"></div>
                </div>
                
                <button id="analyzeBtn" disabled>Анализировать аудио</button>
                
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomInWidth">+ Ширина</button>
                    <button class="zoom-btn" id="zoomOutWidth">- Ширина</button>
                    <span class="zoom-value" id="widthZoomValue">100%</span>
                    
                    <button class="zoom-btn" id="zoomInHeight">+ Высота</button>
                    <button class="zoom-btn" id="zoomOutHeight">- Высота</button>
                    <span class="zoom-value" id="heightZoomValue">100%</span>
                    
                    <button class="zoom-btn" id="resetZoom">Сбросить</button>
                </div>
                
                <div class="spectrogram-container">
                    <div class="frequency-legend">Частота (Гц)</div>
                    <canvas id="spectrogramCanvas" class="spectrogram-canvas"></canvas>
                    <div class="time-legend">Время (сек)</div>
                    <button id="saveSpectrogramBtn" disabled>Сохранить спектрограмму</button>
                </div>
                <div class="status" id="spectrogramStatus"></div>
            </div>
        </div>
    </div>

    <!-- Подключаем библиотеки для улучшения качества звука -->
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/opus-recorder@6.1.0/dist/encoderWorker.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/opus-recorder@6.1.0/dist/recorder.min.js"></script>

    <script>
        // Переключение вкладок
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                this.classList.add('active');
                const tabId = this.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
            });
        });

        // Преобразование изображения в звук
        const imageElements = {
            imageInput: document.getElementById('imageInput'),
            imageCanvas: document.getElementById('imageCanvas'),
            generateAudioBtn: document.getElementById('generateAudioBtn'),
            saveAudioBtn: document.getElementById('saveAudioBtn'),
            audioPlayer: document.getElementById('audioPlayer1'),
            audioControls: document.getElementById('audioControls'),
            progressContainer: document.getElementById('progressContainer1'),
            progressBar: document.getElementById('progressBar1'),
            imageStatus: document.getElementById('imageStatus'),
            audioStatus: document.getElementById('audioStatus1'),
            sliders: {
                duration: document.getElementById('durationSlider'),
                pitch: document.getElementById('pitchSlider'),
                fftSize: document.getElementById('fftSizeSlider1'),
                brightness: document.getElementById('brightnessSlider1'),
                width: document.getElementById('widthSlider'),
                height: document.getElementById('heightSlider'),
                smoothness: document.getElementById('smoothnessSlider'),
                stereoWidth: document.getElementById('stereoWidthSlider')
            },
            values: {
                duration: document.getElementById('durationValue'),
                pitch: document.getElementById('pitchValue'),
                fftSize: document.getElementById('fftSizeValue1'),
                brightness: document.getElementById('brightnessValue1'),
                width: document.getElementById('widthValue'),
                height: document.getElementById('heightValue'),
                smoothness: document.getElementById('smoothnessValue'),
                stereoWidth: document.getElementById('stereoWidthValue')
            },
            keepAspectCheckbox: document.getElementById('keepAspectCheckbox'),
            resizeImageBtn: document.getElementById('resizeImageBtn'),
            sampleRateSelect: document.getElementById('sampleRateSelect'),
            bitDepthSelect: document.getElementById('bitDepthSelect'),
            exportFormat: document.getElementById('exportFormat')
        };

        const imageCtx = imageElements.imageCanvas.getContext('2d');
        let originalImage = null;
        let originalWidth = 0;
        let originalHeight = 0;
        let aspectRatio = 1;

        function setupImageSliders() {
            // Обновляем все слайдеры
            Object.keys(imageElements.sliders).forEach(key => {
                if (imageElements.sliders[key].type === 'range') {
                    imageElements.sliders[key].addEventListener('input', () => {
                        imageElements.values[key].textContent = imageElements.sliders[key].value;
                    });
                }
            });
            
            // Особый случай для FFT size
            imageElements.sliders.fftSize.addEventListener('input', () => {
                const power = parseInt(imageElements.sliders.fftSize.value);
                imageElements.values.fftSize.textContent = Math.pow(2, power);
            });

            imageElements.sliders.width.addEventListener('input', updateDimensions);
            imageElements.sliders.height.addEventListener('input', updateDimensions);
        }

        function updateDimensions() {
            if (imageElements.keepAspectCheckbox.checked && originalWidth > 0 && originalHeight > 0) {
                if (this === imageElements.sliders.width) {
                    const newWidth = parseInt(imageElements.sliders.width.value);
                    const newHeight = Math.round(newWidth / aspectRatio);
                    imageElements.sliders.height.value = newHeight;
                    imageElements.values.height.textContent = newHeight;
                } else {
                    const newHeight = parseInt(imageElements.sliders.height.value);
                    const newWidth = Math.round(newHeight * aspectRatio);
                    imageElements.sliders.width.value = newWidth;
                    imageElements.values.width.textContent = newWidth;
                }
            }

            imageElements.values.width.textContent = imageElements.sliders.width.value;
            imageElements.values.height.textContent = imageElements.sliders.height.value;
        }

        function resizeImage() {
            if (!originalImage) return;

            const newWidth = parseInt(imageElements.sliders.width.value);
            const newHeight = parseInt(imageElements.sliders.height.value);

            imageElements.imageCanvas.width = newWidth;
            imageElements.imageCanvas.height = newHeight;
            imageCtx.drawImage(originalImage, 0, 0, newWidth, newHeight);
            
            imageElements.imageStatus.textContent = `Изображение изменено: ${newWidth}x${newHeight} пикселей`;
        }

        setupImageSliders();

        imageElements.imageInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    originalWidth = img.width;
                    originalHeight = img.height;
                    aspectRatio = originalWidth / originalHeight;

                    imageElements.sliders.width.value = Math.min(originalWidth, 800);
                    imageElements.sliders.height.value = Math.min(originalHeight, 400);
                    imageElements.values.width.textContent = imageElements.sliders.width.value;
                    imageElements.values.height.textContent = imageElements.sliders.height.value;

                    resizeImage();
                    imageElements.generateAudioBtn.disabled = false;
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        imageElements.resizeImageBtn.addEventListener('click', resizeImage);

        imageElements.generateAudioBtn.addEventListener('click', async function() {
            if (imageElements.imageCanvas.width === 0) {
                imageElements.audioStatus.textContent = "Сначала загрузите изображение";
                return;
            }

            imageElements.audioStatus.textContent = "Создание аудио... (это может занять некоторое время)";
            imageElements.generateAudioBtn.disabled = true;
            imageElements.progressContainer.style.display = 'block';
            imageElements.progressBar.style.width = '0%';
            imageElements.progressBar.textContent = '0%';
            
            try {
                const duration = parseFloat(imageElements.sliders.duration.value);
                const pitchFactor = parseFloat(imageElements.sliders.pitch.value);
                const brightnessFactor = parseFloat(imageElements.sliders.brightness.value);
                const smoothness = parseFloat(imageElements.sliders.smoothness.value);
                const stereoWidth = parseFloat(imageElements.sliders.stereoWidth.value);
                const sampleRate = parseInt(imageElements.sampleRateSelect.value);
                const bitDepth = parseInt(imageElements.bitDepthSelect.value);
                
                const audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate });
                const totalSamples = Math.floor(duration * sampleRate);
                
                const imageData = imageCtx.getImageData(0, 0, imageElements.imageCanvas.width, imageElements.imageCanvas.height);
                const pixels = imageData.data;
                
                // Создаем стерео буфер
                const audioBuffer = audioContext.createBuffer(2, totalSamples, sampleRate);
                const leftOutput = audioBuffer.getChannelData(0);
                const rightOutput = audioBuffer.getChannelData(1);
                
                const columnWidth = imageElements.imageCanvas.width / duration;
                const heightFactor = 1 / imageElements.imageCanvas.height;
                
                const chunkSize = Math.floor(totalSamples / 100);
                
                // Параметры для улучшения качества звука
                const minFrequency = 20; // Минимальная частота в Гц
                const maxFrequency = 8000 * pitchFactor; // Максимальная частота с учетом тональности
                const frequencyRange = maxFrequency - minFrequency;
                
                let prevLeftSample = 0;
                let prevRightSample = 0;
                
                for (let i = 0; i < totalSamples; i++) {
                    const time = i / sampleRate;
                    const x = Math.floor(time * columnWidth * pitchFactor) % imageElements.imageCanvas.width;
                    
                    let leftSample = 0;
                    let rightSample = 0;
                    
                    for (let y = 0; y < imageElements.imageCanvas.height; y++) {
                        const idx = (y * imageElements.imageCanvas.width + x) * 4;
                        const r = pixels[idx];
                        const g = pixels[idx + 1];
                        const b = pixels[idx + 2];
                        
                        // Более точный расчет яркости (с учетом восприятия)
                        const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                        
                        // Логарифмическое распределение частот (более естественное для слуха)
                        const freqPosition = Math.pow(y * heightFactor, 2);
                        const frequency = minFrequency + freqPosition * frequencyRange;
                        
                        const phase = time * frequency * 2 * Math.PI;
                        
                        // Амплитуда с учетом нелинейности восприятия громкости
                        const amplitude = Math.pow(brightness, 1.5) * brightnessFactor;
                        
                        // Добавляем стерео эффект
                        const pan = (x / imageElements.imageCanvas.width - 0.5) * 2 * stereoWidth;
                        const leftGain = 0.5 * (1 - pan);
                        const rightGain = 0.5 * (1 + pan);
                        
                        leftSample += leftGain * amplitude * Math.sin(phase);
                        rightSample += rightGain * amplitude * Math.sin(phase);
                    }
                    
                    // Нормализация и применение фильтра
                    leftSample = leftSample / imageElements.imageCanvas.height * 2;
                    rightSample = rightSample / imageElements.imageCanvas.height * 2;
                    
                    leftSample = Math.max(-0.99, Math.min(0.99, leftSample));
                    rightSample = Math.max(-0.99, Math.min(0.99, rightSample));
                    
                    // Применяем фильтр сглаживания
                    leftSample = smoothness * leftSample + (1 - smoothness) * prevLeftSample;
                    rightSample = smoothness * rightSample + (1 - smoothness) * prevRightSample;
                    
                    prevLeftSample = leftSample;
                    prevRightSample = rightSample;
                    
                    leftOutput[i] = leftSample;
                    rightOutput[i] = rightSample;
                    
                    if (i % chunkSize === 0) {
                        const progress = Math.floor((i / totalSamples) * 100);
                        imageElements.progressBar.style.width = `${progress}%`;
                        imageElements.progressBar.textContent = `${progress}%`;
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
                
                // Применяем простой фильтр низких частот для сглаживания
                const applyLowPass = (data, cutoffFreq = 4000) => {
                    const rc = 1.0 / (2 * Math.PI * cutoffFreq);
                    const dt = 1.0 / sampleRate;
                    const alpha = dt / (rc + dt);
                    
                    let lastValue = data[0];
                    for (let i = 1; i < data.length; i++) {
                        lastValue = lastValue + alpha * (data[i] - lastValue);
                        data[i] = lastValue;
                    }
                };
                
                applyLowPass(leftOutput);
                applyLowPass(rightOutput);
                
                imageElements.progressBar.style.width = '100%';
                imageElements.progressBar.textContent = '100%';
                
                // Экспорт в выбранном формате
                const exportFormat = imageElements.exportFormat.value;
                let audioBlob;
                
                if (exportFormat === 'wav') {
                    audioBlob = await bufferToWave(audioBuffer, totalSamples, bitDepth);
                } else if (exportFormat === 'mp3' && typeof lamejs !== 'undefined') {
                    audioBlob = await bufferToMp3(audioBuffer);
                } else if (exportFormat === 'ogg' && typeof Recorder !== 'undefined') {
                    audioBlob = await bufferToOgg(audioBuffer);
                } else {
                    audioBlob = await bufferToWave(audioBuffer, totalSamples, bitDepth);
                }
                
                const audioUrl = URL.createObjectURL(audioBlob);
                imageElements.audioPlayer.src = audioUrl;
                imageElements.audioControls.style.display = 'block';
                
                imageElements.audioStatus.textContent = "Аудио создано!";
                imageElements.generateAudioBtn.disabled = false;
                imageElements.progressContainer.style.display = 'none';
                
                imageElements.saveAudioBtn.onclick = function() {
                    const a = document.createElement('a');
                    a.href = audioUrl;
                    a.download = `image-sound.${exportFormat}`;
                    a.click();
                };
                
            } catch (error) {
                imageElements.audioStatus.textContent = "Ошибка: " + error.message;
                console.error(error);
                imageElements.generateAudioBtn.disabled = false;
                imageElements.progressContainer.style.display = 'none';
            }
        });

        async function bufferToWave(audioBuffer, len, bitDepth = 16) {
            const numOfChan = audioBuffer.numberOfChannels;
            const bytesPerSample = bitDepth / 8;
            const length = len * numOfChan * bytesPerSample + 44;
            const buffer = new ArrayBuffer(length);
            const view = new DataView(buffer);
            let pos = 0;
            
            function setUint16(data) {
                view.setUint16(pos, data, true);
                pos += 2;
            }
            
            function setUint32(data) {
                view.setUint32(pos, data, true);
                pos += 4;
            }
            
            function setInt16(data) {
                view.setInt16(pos, data, true);
                pos += 2;
            }
            
            // WAVE header
            setUint32(0x46464952); // "RIFF"
            setUint32(length - 8); // file length - 8
            setUint32(0x45564157); // "WAVE"
            
            // fmt chunk
            setUint32(0x20746d66); // "fmt "
            setUint32(16); // length = 16
            setUint16(1); // PCM (uncompressed)
            setUint16(numOfChan);
            setUint32(audioBuffer.sampleRate);
            setUint32(audioBuffer.sampleRate * numOfChan * bytesPerSample); // avg. bytes/sec
            setUint16(numOfChan * bytesPerSample); // block-align
            setUint16(bitDepth); // bits per sample
            setUint32(0x61746164); // "data" chunk
            setUint32(length - pos - 4); // chunk length
            
            // Write audio data
            if (bitDepth === 16) {
                for (let channel = 0; channel < numOfChan; channel++) {
                    const chanData = audioBuffer.getChannelData(channel);
                    for (let i = 0; i < chanData.length; i++) {
                        const sample = Math.max(-1, Math.min(1, chanData[i]));
                        setInt16(sample * 32767);
                    }
                }
            } else if (bitDepth === 24) {
                // 24-bit encoding
                for (let channel = 0; channel < numOfChan; channel++) {
                    const chanData = audioBuffer.getChannelData(channel);
                    for (let i = 0; i < chanData.length; i++) {
                        const sample = Math.max(-1, Math.min(1, chanData[i]));
                        const val = sample * 8388607;
                        view.setUint8(pos++, (val >> 16) & 0xff);
                        view.setUint8(pos++, (val >> 8) & 0xff);
                        view.setUint8(pos++, val & 0xff);
                    }
                }
            } else if (bitDepth === 32) {
                // 32-bit float encoding
                for (let channel = 0; channel < numOfChan; channel++) {
                    const chanData = audioBuffer.getChannelData(channel);
                    for (let i = 0; i < chanData.length; i++) {
                        view.setFloat32(pos, chanData[i], true);
                        pos += 4;
                    }
                }
            }
            
            return new Blob([buffer], { type: 'audio/wav' });
        }

        async function bufferToMp3(audioBuffer) {
            const sampleRate = audioBuffer.sampleRate;
            const channels = audioBuffer.numberOfChannels;
            const leftData = audioBuffer.getChannelData(0);
            const rightData = channels > 1 ? audioBuffer.getChannelData(1) : leftData;
            
            const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, 192);
            const samples = new Int16Array(leftData.length * channels);
            
            for (let i = 0; i < leftData.length; i++) {
                samples[i * channels] = leftData[i] * 32767;
                if (channels > 1) {
                    samples[i * channels + 1] = rightData[i] * 32767;
                }
            }
            
            const mp3Data = [];
            const sampleBlockSize = 1152;
            
            for (let i = 0; i < samples.length; i += sampleBlockSize) {
                const chunk = samples.subarray(i, i + sampleBlockSize);
                const mp3buf = mp3encoder.encodeBuffer(chunk);
                if (mp3buf.length > 0) {
                    mp3Data.push(mp3buf);
                }
            }
            
            const mp3buf = mp3encoder.flush();
            if (mp3buf.length > 0) {
                mp3Data.push(mp3buf);
            }
            
            return new Blob(mp3Data, { type: 'audio/mp3' });
        }

        async function bufferToOgg(audioBuffer) {
            return new Promise((resolve) => {
                const recorder = new Recorder({
                    encoderSampleRate: audioBuffer.sampleRate,
                    encoderApplication: 2048, // AUDIO
                    encoderFrameSize: 20, // ms
                    maxFramesPerPage: 40,
                    monitorGain: 0,
                    numberOfChannels: audioBuffer.numberOfChannels,
                    streamPages: false,
                    encoderPath: "https://cdn.jsdelivr.net/npm/opus-recorder@6.1.0/dist/encoderWorker.min.js"
                });
                
                recorder.oncomplete = (blob) => {
                    resolve(blob);
                };
                
                recorder.init(audioBuffer.sampleRate, audioBuffer.numberOfChannels);
                
                // Добавляем данные по кадрам
                const frameSize = 1024;
                const leftData = audioBuffer.getChannelData(0);
                const rightData = audioBuffer.numberOfChannels > 1 ? audioBuffer.getChannelData(1) : leftData;
                
                for (let i = 0; i < leftData.length; i += frameSize) {
                    const leftFrame = leftData.slice(i, i + frameSize);
                    const rightFrame = rightData.slice(i, i + frameSize);
                    const frame = audioBuffer.numberOfChannels > 1 ? [leftFrame, rightFrame] : [leftFrame];
                    recorder.encode(frame);
                }
                
                recorder.complete();
            });
        }

        // Анализатор аудио (остается без изменений)
        const audioElements = {
            audioInput: document.getElementById('audioInput'),
            audioPlayer: document.getElementById('audioPlayer2'),
            spectrogramCanvas: document.getElementById('spectrogramCanvas'),
            analyzeBtn: document.getElementById('analyzeBtn'),
            saveSpectrogramBtn: document.getElementById('saveSpectrogramBtn'),
            audioStatus: document.getElementById('audioStatus2'),
            spectrogramStatus: document.getElementById('spectrogramStatus'),
            progressBar: document.getElementById('progressBar2'),
            progressContainer: document.getElementById('progressContainer2'),
            fftSizeSlider: document.getElementById('fftSizeSlider2'),
            fftSizeValue: document.getElementById('fftSizeValue2'),
            contrastSlider: document.getElementById('contrastSlider'),
            contrastValue: document.getElementById('contrastValue'),
            brightnessSlider: document.getElementById('brightnessSlider2'),
            brightnessValue: document.getElementById('brightnessValue2'),
            zoomInWidth: document.getElementById('zoomInWidth'),
            zoomOutWidth: document.getElementById('zoomOutWidth'),
            zoomInHeight: document.getElementById('zoomInHeight'),
            zoomOutHeight: document.getElementById('zoomOutHeight'),
            resetZoom: document.getElementById('resetZoom'),
            widthValue: document.getElementById('widthZoomValue'),
            heightValue: document.getElementById('heightZoomValue')
        };

        const audioCtx = {
            spectrogram: audioElements.spectrogramCanvas.getContext('2d', { willReadFrequently: true })
        };
        
        let zoom = {
            width: 1,
            height: 1,
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            lastX: 0,
            lastY: 0
        };

        audioElements.fftSizeSlider.addEventListener('input', () => {
            const size = Math.pow(2, parseInt(audioElements.fftSizeSlider.value));
            audioElements.fftSizeValue.textContent = size;
        });
        
        audioElements.contrastSlider.addEventListener('input', () => {
            audioElements.contrastValue.textContent = audioElements.contrastSlider.value;
        });
        
        audioElements.brightnessSlider.addEventListener('input', () => {
            audioElements.brightnessValue.textContent = audioElements.brightnessSlider.value;
        });

        audioElements.audioInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            audioElements.audioStatus.textContent = "Загрузка аудио...";
            audioElements.analyzeBtn.disabled = true;
            audioElements.saveSpectrogramBtn.disabled = true;

            const reader = new FileReader();
            reader.onload = function(event) {
                audioElements.audioPlayer.src = event.target.result;
                audioElements.audioStatus.textContent = "Аудио загружено. Нажмите 'Анализировать аудио'";
                audioElements.analyzeBtn.disabled = false;
            };
            reader.readAsDataURL(file);
        });

        audioElements.analyzeBtn.addEventListener('click', async function() {
            if (!audioElements.audioPlayer.src) {
                audioElements.spectrogramStatus.textContent = "Сначала загрузите аудиофайл";
                return;
            }

            audioElements.spectrogramStatus.textContent = "Анализ аудио...";
            audioElements.analyzeBtn.disabled = true;
            audioElements.saveSpectrogramBtn.disabled = true;
            audioElements.progressContainer.style.display = 'block';
            audioElements.progressBar.style.width = '0%';
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const response = await fetch(audioElements.audioPlayer.src);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                const duration = audioBuffer.duration;
                const sampleRate = audioBuffer.sampleRate;
                const fftSize = Math.pow(2, parseInt(audioElements.fftSizeSlider.value));
                const contrast = parseFloat(audioElements.contrastSlider.value);
                const brightness = parseFloat(audioElements.brightnessSlider.value);
                
                audioElements.spectrogramCanvas.width = Math.min(2500, Math.floor(duration * 100));
                audioElements.spectrogramCanvas.height = 600;
                
                resetZoom();
                
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = fftSize;
                analyser.smoothingTimeConstant = 0.1;
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                
                const scriptNode = audioContext.createScriptProcessor(4096, 1, 1);
                
                const frequencyData = new Uint8Array(analyser.frequencyBinCount);
                let currentX = 0;
                const columnWidth = audioElements.spectrogramCanvas.width / (duration * 20);
                
                function getColor(value) {
                    if (value < 0.2) return '#000000';
                    
                    value = Math.pow(value, contrast) * brightness;
                    value = Math.min(1, Math.max(0, value));
                    
                    const hue = 260 - (value * 260);
                    const saturation = 100;
                    const lightness = value * 70;
                    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                }
                
                scriptNode.onaudioprocess = function() {
                    if (currentX >= audioElements.spectrogramCanvas.width) return;
                    
                    audioElements.progressBar.style.width = `${(currentX / audioElements.spectrogramCanvas.width * 100)}%`;
                    
                    analyser.getByteFrequencyData(frequencyData);
                    
                    for (let y = 0; y < audioElements.spectrogramCanvas.height; y++) {
                        const freqPosition = 1 - Math.log2(audioElements.spectrogramCanvas.height - y + 1) / 
                                            Math.log2(audioElements.spectrogramCanvas.height + 1);
                        const freqIndex = Math.floor(freqPosition * analyser.frequencyBinCount);
                        
                        const value = frequencyData[freqIndex] / 255;
                        audioCtx.spectrogram.fillStyle = getColor(Math.pow(value, 0.5));
                        audioCtx.spectrogram.fillRect(currentX, y, Math.ceil(columnWidth), 1);
                    }
                    
                    currentX += columnWidth;
                };
                
                source.connect(analyser);
                analyser.connect(scriptNode);
                scriptNode.connect(audioContext.destination);
                
                audioElements.saveSpectrogramBtn.onclick = function() {
                    const link = document.createElement('a');
                    link.download = 'spectrogram.png';
                    link.href = audioElements.spectrogramCanvas.toDataURL('image/png');
                    link.click();
                };
                
                source.onended = function() {
                    audioElements.progressBar.style.width = '100%';
                    audioElements.spectrogramStatus.textContent = `Анализ завершен! (${fftSize} точек FFT)`;
                    audioElements.analyzeBtn.disabled = false;
                    audioElements.saveSpectrogramBtn.disabled = false;
                    scriptNode.disconnect();
                };
                
                source.start();
                
            } catch (error) {
                audioElements.spectrogramStatus.textContent = "Ошибка: " + error.message;
                console.error(error);
                audioElements.analyzeBtn.disabled = false;
                audioElements.progressContainer.style.display = 'none';
            }
        });

        function updateZoom() {
            audioElements.spectrogramCanvas.style.width = `${zoom.width * 100}%`;
            audioElements.spectrogramCanvas.style.height = `${zoom.height * 100}%`;
            audioElements.widthValue.textContent = `${Math.round(zoom.width * 100)}%`;
            audioElements.heightValue.textContent = `${Math.round(zoom.height * 100)}%`;
            
            audioElements.spectrogramCanvas.style.transform = `translate(${zoom.offsetX}px, ${zoom.offsetY}px)`;
        }

        function resetZoom() {
            zoom = {
                width: 1,
                height: 1,
                offsetX: 0,
                offsetY: 0,
                isDragging: false,
                lastX: 0,
                lastY: 0
            };
            updateZoom();
        }

        audioElements.zoomInWidth.addEventListener('click', () => {
            zoom.width *= 1.2;
            updateZoom();
        });

        audioElements.zoomOutWidth.addEventListener('click', () => {
            zoom.width /= 1.2;
            updateZoom();
        });

        audioElements.zoomInHeight.addEventListener('click', () => {
            zoom.height *= 1.2;
            updateZoom();
        });

        audioElements.zoomOutHeight.addEventListener('click', () => {
            zoom.height /= 1.2;
            updateZoom();
        });

        audioElements.resetZoom.addEventListener('click', resetZoom);

        audioElements.spectrogramCanvas.addEventListener('mousedown', (e) => {
            zoom.isDragging = true;
            zoom.lastX = e.clientX;
            zoom.lastY = e.clientY;
            audioElements.spectrogramCanvas.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!zoom.isDragging) return;
            
            zoom.offsetX += e.clientX - zoom.lastX;
            zoom.offsetY += e.clientY - zoom.lastY;
            zoom.lastX = e.clientX;
            zoom.lastY = e.clientY;
            
            updateZoom();
        });

        document.addEventListener('mouseup', () => {
            zoom.isDragging = false;
            audioElements.spectrogramCanvas.style.cursor = 'move';
        });
    </script>
</body>
</html>
